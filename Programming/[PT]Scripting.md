# *Scripting e IDEs*

üö®Este material foi criado pela Dra. Ana Julia Velez Rueda e Franco Leonardo Bulgarelli. Est√° licenciado sob
[Creative Commons Attribution-ShareAlike 4.0 International License][cc-por-sa]. √â necess√°rio elementos de [Python Resources](https://flbulgarelli.github.io/recursos-python/), sob a mesma licen√ßa.


[![CC BY-SA 4.0][cc-by-sa-image]][cc-by-sa]

[cc-by-sa]: http://creativecommons.org/licenses/by-sa/4.0/
[cc-by-sa-image]: https://licensebuttons.net/l/by-sa/4.0/88x31.png
[cc-by-sa-shield]: https://img.shields.io/badge/License-CC%20BY--SA%204.0-lightgrey.svg

## O que √© um gui√£o? üí¨

Um _escrito_ (espanhol: guion) √© basicamente um conjunto de instru√ß√µes ordenadas, que t√™m como objectivo resolver uma tarefa espec√≠fica. ‚õî Espera, isso soa muito como a defini√ß√£o de um _programa_, n√£o soa?

Muito bem, j√° nos percebeu! √â que os gui√µes **s√£o** programas, mas t√™m algumas caracter√≠sticas particulares:

 1) Normalmente interagem com bibliotecas de sistemas operativos, quer directamente, quer atrav√©s de comandos bash;
 2) S√£o normalmente executados num terminal (_shell_) e geralmente contra um int√©rprete;
 3) Normalmente n√£o t√™m uma interface gr√°fica, mas todas as interac√ß√µes ocorrem atrav√©s de entrada e sa√≠da de texto;
 4) Eles recebem os seus argumentos do terminal;
 5) Eles devolvem um c√≥digo de sa√≠da num√©rico e inteiro (`0` por defeito e em caso de sucesso);
 6) Operar principalmente contra ficheiros e _data streams_, tais como entrada padr√£o (`stdin`), sa√≠da padr√£o (`stdout`) e erro padr√£o (`stderr`).

Mais concretamente, os gui√µes s√£o geralmente escritos em texto simples, utilizando uma linguagem de programa√ß√£o _interpretada_, tal como Python, Perl, Ruby ou Bash, e o seu comprimento variar√° de acordo com a sua linguagem. Por exemplo, os gui√µes Python utilizam a extens√£o `.py`, e os escritos em Bash, `.sh` (ou sem qualquer extens√£o).

## Porque √© que queremos gui√µes?

Os gui√µes s√£o particularmente √∫teis para automatizar tarefas que decorrem periodicamente (tamb√©m conhecidas como tarefas programadas ou calendarizadas) ou para automatizar situa√ß√µes enfadonhas como, por exemplo

 * Executando um conjunto de programas e combinando os seus resultados;
 * Descarregar, carregar, mover e/ou descompactar ficheiros;
 * Realizar convers√µes de formato;
 * Execu√ß√£o de tarefas de constru√ß√£o de projectos de software, tais como compila√ß√£o, teste e publica√ß√£o; * Execu√ß√£o de tarefas operacionais de manuten√ß√£o de sistemas, tais como: * Execu√ß√£o de tarefas de manuten√ß√£o de sistemas, tais como
 * Execu√ß√£o de tarefas de manuten√ß√£o do sistema operativo, tais como instala√ß√£o e configura√ß√£o de software, liberta√ß√£o de espa√ßo, etc.

## Que l√≠nguas s√£o usadas para a escrita?

Como j√° dissemos, as linguagens utilizadas para a escrita s√£o geralmente interpretadas, ou seja, s√£o executadas directamente contra um programa de interpreta√ß√£o que l√™ e executa as instru√ß√µes, em vez de exigir uma compila√ß√£o pr√©via (como seria por exemplo o caso de Java, C ou Go).

Isto porque quando programamos scripts, preocupamo-nos que a escrita de tais programas seja r√°pida e f√°cil, mas n√£o que a sua execu√ß√£o seja r√°pida (as l√≠nguas compiladas normalmente optimizam o nosso c√≥digo para reduzir o tempo de execu√ß√£o e os recursos em geral). Al√©m disso, as linguagens de scripting tendem a oferecer uma f√°cil integra√ß√£o para executar programas externos, gerir ficheiros e interagir com o sistema operativo em geral.

## Estrutura dos gui√µes Python üß±

Os roteiros t√™m sempre um √∫nico ponto de entrada, ou _main_, que √© o que ser√° executado quando invocado a partir do terminal.

Em Python, podemos fazer isto de duas maneiras. Uma delas √© a forma mais "b√°sica", que √© ter um ficheiro normal `.py`, que importa os pacotes necess√°rios e executa as opera√ß√µes. Por exemplo, digamos que fazemos um gui√£o que diz simplesmente "ol√° mundo" e termina. Para o fazer, escrever√≠amos um ficheiro `hello.py` contendo exactamente isto:

```python
print("ol√° mundo")
```

Em alternativa, podemos escrev√™-lo de uma forma ligeiramente mais complexa, mas mais "cl√°ssica" e conceptualmente correcta:

```python
def main():
    print("ol√° mundo")

se __nome__ == "__main__":
  principal()
```

E √© tudo! Este √© provavelmente um dos gui√µes mais simples que podemos fazer.

## Como √© que gerimos um gui√£o? ü§î

Agora, como √© que o executamos? A forma mais √≥bvia √© correr o ficheiro a partir do terminal, utilizando o caminho absoluto ou relativo para o ficheiro, invocando directamente o int√©rprete apropriado. Por exemplo, ao fazer:


```bash
python3 ol√°.py
```

Embora claramente mais simples, este atalho pode ter algumas desvantagens em rela√ß√£o √† utiliza√ß√£o de todos os passos acima referidos, nomeadamente o facto de for√ßar aqueles que utilizam o nosso gui√£o a saber qual o int√©rprete contra o qual o gui√£o deve ser executado.

Seria melhor se a pessoa que usa o nosso gui√£o n√£o tivesse de saber qual o int√©rprete contra o qual comparar o ficheiro, n√£o seria? Por outras palavras, poder simplesmente fazer `./hello.py`. Mas como √© que o sistema reconheceria que este ficheiro, que √† primeira vista parece um ficheiro de texto comum, tem de ser executado como um gui√£o?

Em **linux** todos os ficheiros de texto simples s√£o apenas texto simples, por isso n√£o importa a extens√£o que lhes d√™s, por isso tens de dizer de alguma forma que um determinado ficheiro √© um script contendo comandos a serem executados. Para isso, precisamos:

1) Primeiro, o primeiro √© normalmente digitado `#!`, que √© conhecido como shebang, seguido pelo caminho do int√©rprete contra o qual o programa ser√° executado (python neste caso). Em sistemas Linux √©: `#!/bin/python3`.

2) Em segundo lugar, o ficheiro deve ter permiss√µes de execu√ß√£o. Como j√° vimos, este √∫ltimo pode ser feito utilizando o comando `chmod` cujas op√ß√µes s√£o:

    `+r`, `+w` ou `+x` para dar permiss√µes de leitura, escrita ou execu√ß√£o a um ficheiro, respectivamente.

    `-r`, `-w` ou `-x` para os remover.


    Estas op√ß√µes podem ser combinadas, portanto, se eu quiser dar todas as permiss√µes a um ficheiro que eu possa fazer:

    ```bash
    chmod +rwx ficheiro
    ```

3) Finalmente, devemos executar o ficheiro utilizando o caminho completo (absoluto) para o ficheiro ou estando na pasta onde o ficheiro se encontra podemos utilizar o `./nome_script.py`.

Por exemplo, o nosso `hello.py` ter√° este aspecto:

```python
/bin/python3

def main():
    print("ol√° mundo")

se __nome__ == "__main__":
  principal()
```

## IDEs ou Ambientes de Desenvolvimento 

Para escrever confortavelmente os nossos roteiros precisaremos de uma ferramenta chamada editor de c√≥digo, que se parece muito com um editor de texto, mas n√£o √© para escrever poemas, curr√≠culos, ou trabalhos escolares (onde nos preocuparemos com a verifica√ß√£o ortogr√°fica, sublinhado, dobrado, ou mudan√ßa de cores), mas sim para criar programas complexos. :star_struck:

Muitos destes editores de c√≥digo (ou editores simples, a partir de agora) podem ser instalados no seu pr√≥prio computador. Algumas delas s√£o:

* [Sublime](https://www.sublimetext.com/);
* [Visual Studio Code](https://code.visualstudio.com/);
* [Atom](https://atom.io/);
* [Vim](https://www.vim.org/).

Al√©m disso, para desenvolver aplica√ß√µes e sistemas mais complexos, existem ferramentas ainda mais completas (e complexas! :sweat:) conhecidas como Ambientes de Desenvolvimento Integrado (_IDEs_). Uma das mais populares √© [PyCharm](https://www.jetbrains.com/es-es/pycharm/). Existem tamb√©m IDEs em linha tais como [Colaboratory](https://colab.research.google.com/) e [Jupyter](https://jupyter.org/) que n√£o requerem que as descarregue para o seu computador. :m√∫sculo:

Com excep√ß√£o do Colab, para utilizar qualquer um destes editores e ambientes de desenvolvimento, teremos de os instalar nos nossos computadores. E com isso, seremos capazes de programar e executar os nossos gui√µes, n√£o √© verdade?

N√£o! porque os editores s√£o apenas ferramentas para escrever c√≥digo, e n√£o v√™m com Python üòí. Vejamos ent√£o antes de continuarmos como instalar todas estas coisas.

### üíª Instalar o ambiente local 

> Nota: este guia √© orientado para uma instala√ß√£o local no Linux. Se tiver o Windows, [aqui](https://code.visualstudio.com/docs/python/python-tutorial) encontrar√° mais informa√ß√µes.

Para utilizar Python localmente (isto √©, no seu computador em vez de numa plataforma online como [Replit](https://replit.com/) ou [Mumuki](https://mumuki.io)) precisaremos de instalar algum software. Abrir um terminal. Notar√° que algo semelhante ao que se segue aparece:

```shell
my_name@my_computer:~$
```

O que isto indica √© que est√° ligado ao computador `my_computer` com um utilizador chamado `my_name`. Al√©m disso, o sinal `$` (tamb√©m chamado de prompt) indica que o terminal est√° pronto para aceitar comandos. Finalmente, o s√≠mbolo `~` indica que est√° no direct√≥rio home do `my_name`, tamb√©m chamado _home_.

E que comandos se pode executar? Aqui est√£o alguns dos (tantos) dispon√≠veis:

  * `cd`: mudar direct√≥rio
  *`ls`: mostrar o conte√∫do do direct√≥rio
  * `pwd`: mostrar direct√≥rio actual

A forma mais f√°cil de instalar o Python no Ubuntu (20.04 ou superior) √© com o seguinte comando:

```bash
sudo apt install python3 python-is-python3 python3-pip
```

O C√≥digo Visual √© um dos editores de c√≥digo mais comuns e flex√≠veis (em 2023). Por isso, neste tutorial vamos escolh√™-lo. Para o instalarmos no Ubuntu, vamos executar o seguinte:

```bash
sudo snap install code
```

Ou, se este comando gerar um aviso, podemos fazer o seguinte:

```bash
$ sudo snap install code --classic
```

Chegou a hora de testar tudo! Para editar um ficheiro, pode abrir C√≥digo Visual a partir do menu de aplica√ß√£o, ou executando o comando ``c√≥digo` num terminal. Exemplo:

```bash
$ c√≥digo mi_script.py
```

> Nota: O suporte por defeito do C√≥digo Visual para Python √© limitado. Se quiser melhorar o apoio pode instalar a extens√£o oficial Python, a partir do menu Extens√µes (_Extens√µes_, na barra lateral esquerda). A√≠ dever√° procurar por "Python" e escolher a extens√£o fornecida pela Microsoft:
>
> ![captura de ecr√£ de c√≥digo visual](./vs_python_extension.png)

Depois, para executar o conte√∫do do ficheiro, pode faz√™-lo:

```bash
$ python3 mi_script.py
```
## Um gui√£o mais complexo üí™

Agora que temos todas as ferramentas instaladas e sabemos como criar e executar gui√µes, vamos olhar para um exemplo ligeiramente mais complexo de um gui√£o para nos dar uma vis√£o do grande potencial dos gui√µes no nosso trabalho di√°rio.

Como mencionado anteriormente, os scripts geralmente interagem com o sistema de ficheiros (_Sistema de ficheiros_ ou _FS_) e o sistema operativo em geral (_Sistema Operativo_ ou _OS_). √â precisamente por esta raz√£o que o m√≥dulo 'os' de Python (https://docs.python.org/es/3.10/library/os.html) ser√° de particular ajuda na escrita dos seus gui√µes. A√≠ encontrar√° opera√ß√µes como as que se seguem:

  * `os.stat`: permite-nos obter estat√≠sticas sobre um ficheiro (tal como o seu tamanho).
  * ``os.rename`: permite-nos renomear ficheiros
  * `os.rmdir`: permite-nos eliminar direct√≥rios.

Da mesma forma, [o subm√≥dulo `os.path`](https://docs.python.org/3/library/os.path.html) dar-nos-√° mais funcionalidades para interagir com ficheiros e os seus caminhos:

 * `os.path.dirname`: permite-nos obter o direct√≥rio onde um ficheiro est√° contido.
 * 'os.path.exists': permite-nos saber se um ficheiro existe
 * 'os.path.join': permite-nos concatenar caminhos (por exemplo, combinar '/um' e 'caminho' para obter '/um/caminho')

Finalmente, [o m√≥dulo `sys`](https://docs.python.org/es/3/library/sys.html) dar-nos-√° acesso a `sys.argv`: uma lista contendo o nome do gui√£o e os argumentos com os quais um programa foi executado.

Vamos ver um pequeno exemplo! Criar o seguinte gui√£o `stats.py`.

```python
/bin/python3

importar os
sistema de importa√ß√£o
de data/hora de importa√ß√£o # de data para transformar datas

ficheiro = sys.argv[1] # o primeiro par√¢metro corresponde √† posi√ß√£o 1,
                      # desde que a posi√ß√£o 0 cont√©m o nome do gui√£o

imprimir("Obter informa√ß√£o de ficheiro", ficheiro)

statistics = os.stat(file)
print("Weighhs:", statistics.st_size, "bytes")
print("Last modified:", datetime.utcfromtimestamp(stats.st_atime).strftime('%Y-%m-%d %H:%M:%S'))
```

A fim de tornar o nosso gui√£o execut√°vel, temos de fazer o seguinte:

```bash
chmod u+x stats.py
```

E agora podemos geri-lo desta forma:

```bash
./stats.py '[ES]Scripting.md'.
Obter informa√ß√£o do ficheiro [ES]Scripting.md
Peso: 11730 bytes
√öltima modifica√ß√£o: 2023-01-15 17:26:31 AM
```

> üßóüèª‚ôÄÔ∏è Desafio final! Criar um gui√£o `swap.py` que toma dois nomes de ficheiro e renomeia o primeiro com o nome do segundo, e renomeia o segundo com o nome do primeiro.
> Exemplo:
>
> ```bash
> $ cat hello.txt
> ol√°
> $ $ $ cat hello.txt
> ```
> ```bash
> $ ./swap.py hello.txt chau.txt chau.txt
> $ $ $ cat hello.txt
> chau
> $ $ $ gato chau.txt
> ol√°
> ```



## Ningu√©m tem a √∫ltima palavra aqui

At√© agora, vimos o que √© um gui√£o, os seus usos e as ferramentas que podemos utilizar para os desenvolver. No entanto, √© importante ter em mente que as ferramentas s√£o apenas isso: ferramentas üõ†Ô∏è. E tal como acontece com as linguagens de programa√ß√£o, n√£o h√° uma melhor do que a outra, mas existem ferramentas mais apropriadas do que outras para uma ou outra utiliza√ß√£o.

√â por isso que para desenvolver scripts mostramos IDEs como [Visual Studio Code](https://code.visualstudio.com/), que s√£o particularmente √∫teis quando estamos a desenvolver certos tipos de projectos como os que fizemos como exemplo, onde n√£o foi necess√°rio mostrar interactivamente tabelas ou gr√°ficos üìä.

Mas, no mundo dos dados, manipular tabelas e analisar gr√°ficos √© uma coisa di√°ria, por isso, neste mundo podemos encontrar outras ferramentas muito √∫teis que nos permitem explorar e visualizar tabelas e gr√°ficos sem a necessidade de ter milhares de separadores abertos.

Em Python, existem os chamados cadernos interactivos (ou `ipynb`s, para abreviar _ Caderno Interactivo Python_). Este tipo de ficheiro permitir-nos-√° resolver problemas mais complexos, tais como os que vimos at√© agora, mas tamb√©m os que teremos de fazer quando trabalharmos com dados.

Embora no nosso curso iremos utilizar os `Notebooks` para desenvolver c√≥digo Python, eles podem ser utilizados para desenvolver noutras linguagens de programa√ß√£o tamb√©m comuns no mundo dos dados: Julia, Python e R.

A forma mais f√°cil de come√ßar a trabalhar com os cadernos interactivos √© utilizando a plataforma [Colab](https://colab.research.google.com) do Google, mas lembre-se que tamb√©m pode execut√°-los e cri√°-los localmente utilizando [Visual Studio Code](https://code.visualstudio.com/) ou outro IDE espec√≠fico para este tipo de ficheiros como [Juptyer](https://jupyter.org/install) üî¨.

Dentro de qualquer uma destas plataformas poder√° criar cadernos de notas, nos quais coexistir√£o fragmentos (chamados _c√©lulas_) de texto (para tomar notas) e c√≥digo (para executar experi√™ncias):

![colab](Colab[PT].png)


:checkered_flag: Depois de ter sido capaz de criar um caderno em Juyter ou Colab, como mostra a figura, pode come√ßar a trabalhar nos seus dados üìà üí™
